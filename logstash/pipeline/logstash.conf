input {
  beats {
    port => 5044
  }
}

filter {
  # Parse JSON logs from Spring Boot
  if [fields][log_type] == "application" {
    json {
      source => "message"
      target => "parsed"
    }
    
    # Extract timestamp
    if [parsed][timestamp] {
      date {
        match => [ "parsed[timestamp]", "yyyy-MM-dd HH:mm:ss.SSS" ]
        target => "@timestamp"
      }
    }
    
    # Extract log level
    if [parsed][level] {
      mutate {
        add_field => { "log_level" => "%{[parsed][level]}" }
      }
    }
    
    # Extract logger name
    if [parsed][logger] {
      mutate {
        add_field => { "logger_name" => "%{[parsed][logger]}" }
      }
    }
    
    # Extract thread name
    if [parsed][thread] {
      mutate {
        add_field => { "thread_name" => "%{[parsed][thread]}" }
      }
    }
    
    # Extract message
    if [parsed][message] {
      mutate {
        add_field => { "log_message" => "%{[parsed][message]}" }
      }
    }
    
    # Extract exception information
    if [parsed][exception] {
      mutate {
        add_field => { "exception" => "%{[parsed][exception]}" }
      }
    }
    
    # Extract stack trace
    if [parsed][stack_trace] {
      mutate {
        add_field => { "stack_trace" => "%{[parsed][stack_trace]}" }
      }
    }
    
    # Extract HTTP request information if present
    if [parsed][http] {
      if [parsed][http][request] {
        mutate {
          add_field => { "http_method" => "%{[parsed][http][request][method]}" }
          add_field => { "http_path" => "%{[parsed][http][request][path]}" }
          add_field => { "http_remote_address" => "%{[parsed][http][request][remote_address]}" }
        }
      }
      if [parsed][http][response] {
        mutate {
          add_field => { "http_status" => "%{[parsed][http][response][status]}" }
        }
      }
    }
    
    # Extract custom fields
    if [parsed][fields] {
      ruby {
        code => "
          if event.get('[parsed][fields]')
            event.get('[parsed][fields]').each do |key, value|
              event.set(\"custom_#{key}\", value)
            end
          end
        "
      }
    }
    
    # Add application name
    mutate {
      add_field => { "application" => "mongodemo" }
    }
    
    # Add environment tag
    mutate {
      add_field => { "environment" => "development" }
    }
  }
  
  # Parse access logs
  if [fields][log_type] == "access" {
    grok {
      match => { 
        "message" => "%{IPORHOST:remote_ip} - %{DATA:user} \[%{HTTPDATE:timestamp}\] \"%{WORD:http_method} %{URIPATH:http_path}(?:%{URIPARAM:http_params})? HTTP/%{NUMBER:http_version}\" %{NUMBER:http_status} %{NUMBER:response_time} \"%{DATA:referrer}\" \"%{DATA:user_agent}\""
      }
    }
    
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    }
    
    mutate {
      add_field => { "application" => "mongodemo" }
      add_field => { "log_type" => "access" }
    }
  }
  
  # Add geoip information for remote IPs
  if [http_remote_address] {
    geoip {
      source => "http_remote_address"
      target => "geoip"
    }
  }
  
  # Remove parsed field to avoid duplication
  mutate {
    remove_field => [ "parsed" ]
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "mongodemo-logs-%{+YYYY.MM.dd}"
    template_name => "mongodemo-logs"
    template => "/usr/share/logstash/templates/mongodemo-logs-template.json"
    template_overwrite => true
    manage_template => true
  }
  
  # Uncomment for debugging
  # stdout { codec => rubydebug }
}

